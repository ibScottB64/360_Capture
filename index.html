<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360 Capture Guide</title>
    <style>
        /* Basic Reset & Body Styling */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* justify-content: center; REMOVED: This caused content to be pushed off-screen */
            min-height: 100vh; /* Still ensure background fills viewport */
            margin: 0;
            background-color: #f0f0f0;
            color: #333;
            overflow-x: hidden; /* Prevent horizontal scroll */
            box-sizing: border-box;
            padding-bottom: 20px; /* Add some space at the bottom */
        }

        /* NEW: Styles for the main content wrapper */
        .content-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%; /* Take available width */
            max-width: 600px; /* Set a consistent max-width for main content */
            padding: 0 15px; /* Add horizontal padding so content isn't edge-to-edge */
            box-sizing: border-box; /* Include padding in width calculation */
            flex-grow: 1; /* Allow wrapper to grow if needed */
        }

        /* Camera Preview */
        #camera-preview {
            width: 100%;
            max-width: 600px; /* Match wrapper max-width */
            height: auto;
            aspect-ratio: 4 / 3; /* Maintain aspect ratio */
            background-color: #ccc;
            border: 2px solid #555;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transform: scaleX(-1); /* Mirror the preview */
            display: none; /* Hidden until stream is ready */
            object-fit: cover; /* Ensure video fills the aspect ratio */
            margin-bottom: 15px; /* Add space below preview */
        }

        /* Instructions and Status */
        #instructions, #status-message {
            margin: 10px 0; /* Reduce margin */
            text-align: center;
            /* max-width: 500px; */ /* Let wrapper handle max width */
            font-size: 1.1em;
            line-height: 1.5;
        }
        #status-message {
            font-weight: bold;
            color: #007bff;
        }

        /* Buttons */
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            font-size: 1.1em;
            cursor: pointer;
            margin: 10px 5px;
            transition: background-color 0.3s ease;
            width: 90%; /* Make buttons wider */
            max-width: 300px; /* Limit button width */
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        /* Progress Indicator Area */
        #progress-area {
            width: 100%;
            max-width: 600px; /* Match wrapper max-width */
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px; /* Add space above the progress area */
        }

        #progress-container {
            width: 100%;
            height: 60px; /* Fixed height for the progress bar */
            background-color: white;
            border: 2px solid #ccc;
            display: flex;
            overflow: hidden; /* Important to clip child elements */
            position: relative; /* For absolute positioning of elements if needed */
            border-radius: 5px;
            margin-bottom: 10px;
        }

        #progress-rect {
            height: 100%;
            background: linear-gradient(to right, #e0e0e0, #f8f8f8); /* Subtle gradient */
            display: flex; /* Use flex for image segments */
            transition: width 0.2s ease-out; /* Smoothly expand the filled part */
        }

        .progress-segment {
            height: 100%;
            flex-shrink: 0; /* Prevent shrinking */
            object-fit: cover; /* Ensure image covers segment area */
            background-color: #eee; /* Placeholder color */
            border-right: 1px solid #ddd; /* Visual separator */
        }
        .progress-segment:last-child {
            border-right: none;
        }


        /* Tilt Indicator */
        #tilt-indicator {
            width: 100%; /* Make it fill the wrapper width */
            height: 30px;
            background-color: rgba(255, 255, 255, 0.7);
            border: 1px solid #aaa;
            margin: 10px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            position: relative;
        }
        #tilt-indicator::before,
        #tilt-indicator::after {
            content: '';
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 5px;
            height: 20px;
            background-color: #ccc; /* Default neutral color */
            border-radius: 3px;
        }
        #tilt-indicator::before {
            left: 25%;
        }
        #tilt-indicator::after {
            right: 25%;
        }
        .tilt-warning {
            background-color: rgba(255, 193, 7, 0.7); /* Amber */
        }
        .tilt-warning::before,
        .tilt-warning::after {
            background-color: #ffc107; /* Amber indicator */
        }
        .tilt-danger {
             background-color: rgba(220, 53, 69, 0.7); /* Red */
        }
        .tilt-danger::before,
        .tilt-danger::after {
             background-color: #dc3545; /* Red indicator */
        }
        #tilt-indicator span {
            font-size: 0.9em;
            font-weight: bold;
            color: #555;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }


        /* Speed Indicator */
        #speed-indicator {
            width: 100%; /* Make it fill the wrapper width */
            height: 25px;
            background-color: #e0e0e0;
            border-radius: 5px;
            margin-top: 5px;
            position: relative;
            overflow: hidden;
        }
        #speed-meter {
            height: 100%;
            width: 0%;
            background-color: #28a745; /* Green */
            transition: width 0.2s ease-out;
        }
        #speed-indicator-text {
             position: absolute;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             font-size: 0.8em;
             color: white;
             font-weight: bold;
             text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
        }

        /* Final Controls */
        #final-controls {
            display: none; /* Hidden until capture is complete */
            margin-top: 20px;
            width: 100%; /* Ensure controls take full width */
            display: flex;
            justify-content: center; /* Center buttons within this div */
            flex-wrap: wrap; /* Allow buttons to wrap on small screens */
        }
        #final-controls button {
            width: 45%; /* Make buttons take up roughly half the width */
            max-width: 200px; /* Limit width */
        }


        /* Media Queries for smaller screens */
        @media (max-width: 768px) {
            /* Adjust padding for wrapper if needed */
            .content-wrapper {
                padding: 0 10px; /* Slightly less padding on very small screens */
            }

            #camera-preview {
                aspect-ratio: 1 / 1; /* Different aspect ratio on smaller screens */
                margin-bottom: 10px; /* Reduce margin */
            }
            #instructions, #status-message {
                 font-size: 1em;
                 margin: 5px 0; /* Reduce margins further */
            }
            #progress-area {
                margin-top: 10px; /* Reduce margin */
            }
            button {
                margin: 5px 5px; /* Reduce button margins */
                font-size: 1em; /* Slightly smaller font */
                padding: 10px 20px;
            }
            /* Adjust indicators to fill width better */
            #tilt-indicator, #speed-indicator {
                width: 100%; /* Ensure they use wrapper width */
                max-width: none; /* Remove max-width constraint */
            }
            #final-controls button {
                 width: 90%; /* Make buttons stack vertically on very small screens */
                 max-width: 300px;
            }
        }
    </style>
</head>
<body>

    <!-- NEW WRAPPER START -->
    <div class="content-wrapper">
        <h1>360 Photo Capture</h1>

        <video id="camera-preview" autoplay playsinline muted></video>

        <p id="instructions">
            Requesting camera permissions... Please grant access if prompted.
        </p>

        <button id="start-capture">Request Permissions</button>

        <div id="progress-area">
            <div id="progress-container">
                <div id="progress-rect">
                    <!-- Image segments will be appended here -->
                </div>
            </div>
            <div id="tilt-indicator">
                <span>Aim slightly down</span>
                <!-- Indicators change based on tilt -->
            </div>
            <div id="speed-indicator">
                <div id="speed-meter"></div>
                <div id="speed-indicator-text">0째/s</div>
            </div>
        </div>

        <div id="final-controls">
            <button id="submit-capture">Submit</button>
            <button id="retake-capture">Retake</button>
        </div>

        <p id="status-message"></p>
    </div>
    <!-- NEW WRAPPER END -->

    <script>
        // --- Configuration ---
        const TARGET_ROTATION_DEGREES = 360;
        const OVERLAP_DEGREES = 20; // Each image overlaps the previous one by this amount
        const MAX_SPEED_DPS = 45; // Max degrees per second to avoid blur (adjust as needed)
        const TILT_WARNING_THRESHOLD = 15; // Degrees deviation from horizontal (beta=0) for warning
        const TILT_DANGER_THRESHOLD = 30; // Degrees deviation for danger (more aggressive warning)
        const HIGH_RES_WIDTH = 3840; // Target high resolution width (check device capabilities)
        const HIGH_RES_HEIGHT = 2160; // Target high resolution height
        const IMAGE_FORMAT = 'image/jpeg'; // or 'image/png'
        const IMAGE_QUALITY = 0.92; // Quality for JPEG
        const UPLOAD_URL = '/api/upload-360-images'; // Placeholder URL

        // --- DOM Elements ---
        const cameraPreview = document.getElementById('camera-preview');
        const startCaptureButton = document.getElementById('start-capture');
        const submitCaptureButton = document.getElementById('submit-capture');
        const retakeCaptureButton = document.getElementById('retake-capture');
        const instructionsText = document.getElementById('instructions');
        const statusMessage = document.getElementById('status-message');
        const progressRect = document.getElementById('progress-rect');
        const tiltIndicator = document.getElementById('tilt-indicator');
        const speedMeter = document.getElementById('speed-meter');
        const speedIndicatorText = document.getElementById('speed-indicator-text');
        const finalControlsDiv = document.getElementById('final-controls');

        // --- State Variables ---
        let videoStream = null;
        let highResCanvas = null;
        let highResCtx = null;
        let capturedImages = []; // Array to store image Blobs
        let isCapturing = false;
        let isRecording = false; // Tracks if we are actively processing captures
        let initialAlpha = null; // Alpha angle at the start of capture
        let lastAlpha = null;
        let lastTimestamp = null;
        let currentRotation = 0; // Tracks the total degrees covered by captured segments
        let animationFrameId = null;
        let numSegments = Math.ceil(TARGET_ROTATION_DEGREES / (TARGET_ROTATION_DEGREES / Math.ceil(TARGET_ROTATION_DEGREES / OVERLAP_DEGREES) )); // Recalculate segments based on overlap
        let segmentWidthPx = 0; // Calculated width for each segment in progress bar

        // --- Permissions ---
        async function requestPermissions() {
            statusMessage.textContent = 'Requesting camera access...';
            instructionsText.textContent = 'Please grant camera permission when prompted.';
            startCaptureButton.disabled = true; // Temporarily disable while requesting
            startCaptureButton.textContent = 'Requesting...';

            try {
                // Request camera permission
                videoStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment', // Use rear camera
                        width: { ideal: HIGH_RES_WIDTH },
                        height: { ideal: HIGH_RES_HEIGHT },
                        frameRate: { ideal: 30 } // Request a decent frame rate
                    },
                    audio: false
                });

                cameraPreview.srcObject = videoStream;
                cameraPreview.style.display = 'block'; // Show preview once stream is ready
                statusMessage.textContent = 'Camera ready. Stand by...';

                // Wait for the video to be ready to get metadata like aspect ratio if needed
                await new Promise((resolve) => {
                    cameraPreview.onloadedmetadata = resolve;
                });

                // Device orientation permission (optional, some browsers handle implicitly)
                if (typeof DeviceOrientationEvent !== 'undefined' && DeviceOrientationEvent.requestPermission) {
                    // iOS 13+ needs explicit permission
                    const permissionState = await DeviceOrientationEvent.requestPermission();
                    if (permissionState === 'granted') {
                         statusMessage.textContent = 'Camera & Motion permissions granted. Ready to start.';
                         instructionsText.textContent = "Identify a starting feature. Hold your phone vertically. Tap 'Start Capture' when ready.";
                         startCaptureButton.disabled = false;
                         startCaptureButton.textContent = 'Start Capture';
                    } else {
                        throw new Error("Motion and orientation access denied.");
                    }
                } else {
                     statusMessage.textContent = 'Camera permission granted. Ready to start.';
                     instructionsText.textContent = "Identify a starting feature. Hold your phone vertically. Tap 'Start Capture' when ready.";
                     startCaptureButton.disabled = false;
                     startCaptureButton.textContent = 'Start Capture';
                }

                return true;

            } catch (err) {
                console.error("Error accessing media devices or permissions:", err);
                let userMessage = `Error: ${err.message}. Please ensure camera/motion permissions are granted in your browser settings.`;
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                     userMessage = "Permission denied. Please grant camera and motion access in your browser's site settings for this page.";
                } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                     userMessage = "Camera not found. Please ensure your device has a working camera.";
                } else if (err.message.includes("motion and orientation access denied")) {
                    userMessage = "Motion and orientation access denied. Please grant permission for motion sensors.";
                }
                statusMessage.textContent = userMessage;
                instructionsText.textContent = "Please grant permissions via browser settings.";
                startCaptureButton.disabled = false; // Re-enable to allow trying again
                startCaptureButton.textContent = 'Retry Permissions';
                return false;
            }
        }

        // --- High-Resolution Capture ---
        function setupHighResCanvas() {
            if (!highResCanvas) {
                highResCanvas = document.createElement('canvas');
                highResCtx = highResCanvas.getContext('2d');
            }
            // Set canvas dimensions to match the video stream's actual dimensions
            highResCanvas.width = cameraPreview.videoWidth || HIGH_RES_WIDTH;
            highResCanvas.height = cameraPreview.videoHeight || HIGH_RES_HEIGHT;
        }

        function captureFrameAsBlob() {
            if (!highResCanvas || !highResCtx || !isCapturing) return null;

            setupHighResCanvas(); // Ensure canvas is correctly sized

            // Draw the current video frame onto the canvas, correcting for mirroring
            highResCtx.save();
            highResCtx.scale(-1, 1); // Mirror context horizontally
            // Draw mirrored frame to the canvas at the correct position (-width, 0)
            highResCtx.drawImage(cameraPreview, -highResCanvas.width, 0, highResCanvas.width, highResCanvas.height);
            highResCtx.restore();

            return new Promise(resolve => {
                highResCanvas.toBlob(blob => {
                    resolve(blob);
                }, IMAGE_FORMAT, IMAGE_QUALITY);
            });
        }

        // --- Progress Indicator Management ---
        function updateProgressIndicator(imageBlob) {
            if (!imageBlob) return;

            const segmentIndex = capturedImages.length - 1; // Current image is the latest capture
            const segmentAngle = TARGET_ROTATION_DEGREES / numSegments;
            const segmentWidthRatio = segmentAngle / TARGET_ROTATION_DEGREES;

            const segmentCanvas = document.createElement('canvas');
            segmentCanvas.className = 'progress-segment';
            segmentCanvas.style.width = `${segmentWidthRatio * 100}%`; // Set width as percentage

            const segmentCtx = segmentCanvas.getContext('2d');
            const img = new Image();
            img.onload = () => {
                // Scale image to fit the segment while maintaining aspect ratio
                const segmentAspectRatio = segmentCanvas.width / segmentCanvas.height;
                const imageAspectRatio = img.width / img.height;

                let drawWidth, drawHeight, drawX, drawY;

                if (imageAspectRatio > segmentAspectRatio) {
                    drawWidth = segmentCanvas.width;
                    drawHeight = segmentCanvas.width / imageAspectRatio;
                    drawX = 0;
                    drawY = (segmentCanvas.height - drawHeight) / 2; // Center vertically
                } else {
                    drawHeight = segmentCanvas.height;
                    drawWidth = segmentCanvas.height * imageAspectRatio;
                    drawY = 0;
                    drawX = (segmentCanvas.width - drawWidth) / 2; // Center horizontally
                }
                segmentCtx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
            };
            img.src = URL.createObjectURL(imageBlob);

            progressRect.appendChild(segmentCanvas);

            // Update the filled width of the progress bar visually
            // Use currentRotation which is updated when a segment is captured
            const filledWidthPercentage = Math.min((currentRotation / TARGET_ROTATION_DEGREES) * 100, 100);
            progressRect.style.width = `${filledWidthPercentage}%`;
        }

        // --- Orientation Handling ---
        function handleOrientation(event) {
            if (!isCapturing || !event.alpha || !event.beta || !event.gamma) return;

            const alpha = event.alpha; // Rotation around Z axis (left-right turn)
            const beta = event.beta;   // Rotation around X axis (up-down tilt)
            const gamma = event.gamma; // Rotation around Y axis (left-right tilt)
            const timestamp = performance.now();

            // Initialize on first reading after capture starts
            if (initialAlpha === null) {
                initialAlpha = alpha;
                lastAlpha = alpha;
                lastTimestamp = timestamp;
                updateTiltIndicator(beta); // Update tilt based on initial orientation
                return;
            }

            // Calculate rotation delta from the *last recorded orientation*
            let deltaAlpha = alpha - lastAlpha;

            // Handle angle wrap-around (e.g., 359 -> 1 degree)
            if (deltaAlpha > 180) deltaAlpha -= 360;
            if (deltaAlpha < -180) deltaAlpha += 360;

            const deltaTime = timestamp - lastTimestamp;
            // Avoid division by zero if timestamp is the same
            const rotationSpeed = (deltaTime > 0) ? Math.abs(deltaAlpha) / (deltaTime / 1000) : 0; // Degrees per second

            // Update speed indicator
            updateSpeedIndicator(rotationSpeed);

            // Update tilt indicator
            updateTiltIndicator(beta);

            // Calculate current absolute rotation relative to the start
            let currentAbsoluteRotation = alpha - initialAlpha;
            // Normalize to 0-360 degrees range
            if (currentAbsoluteRotation > 180) currentAbsoluteRotation -= 360;
            if (currentAbsoluteRotation < -180) currentAbsoluteRotation += 360;
            currentAbsoluteRotation = (currentAbsoluteRotation + 360) % 360;

            // --- Capture Condition ---
            // Capture the next image if:
            // 1. We haven't captured all required segments yet.
            // 2. The current rotation has passed the boundary for the next segment.
            // 3. The rotation speed is acceptable.
            // We track the progress using `currentRotation`, which represents the total degrees covered by the *captured* segments.
            // We need to capture when `currentAbsoluteRotation` crosses `(capturedImages.length + 1) * segmentAngle`.

            const segmentAngle = TARGET_ROTATION_DEGREES / numSegments;
            const requiredAngleForNextCapture = (capturedImages.length + 1) * segmentAngle;

            // Check if we've rotated past the boundary for the next segment
            // Use a small tolerance to ensure we capture even if movement is slightly uneven
            const rotationThreshold = (capturedImages.length === 0) ? segmentAngle / 2 : segmentAngle; // Start with half segment for first image after initial

            let angleMovedSinceLastCapture = 0;
            if (lastAlpha !== null) {
                angleMovedSinceLastCapture = alpha - lastAlpha;
                if (angleMovedSinceLastCapture > 180) angleMovedSinceLastCapture -= 360;
                if (angleMovedSinceLastCapture < -180) angleMovedSinceLastCapture += 360;
                angleMovedSinceLastCapture = Math.abs(angleMovedSinceLastCapture);
            } else {
                // For the very first capture after the initial one
                 angleMovedSinceLastCapture = Math.abs(alpha - initialAlpha);
                 if (angleMovedSinceLastCapture > 180) angleMovedSinceLastCapture -= 360;
                 if (angleMovedSinceLastCapture < -180) angleMovedSinceLastCapture += 360;
                 angleMovedSinceLastCapture = Math.abs(angleMovedSinceLastCapture);
            }


            // Trigger capture if:
            // 1. We still need more segments (`capturedImages.length < numSegments`)
            // 2. We have rotated at least `rotationThreshold` degrees since the last capture trigger.
            // 3. The rotation speed is below the `MAX_SPEED_DPS` limit.
            if (capturedImages.length < numSegments &&
                angleMovedSinceLastCapture >= rotationThreshold &&
                rotationSpeed < MAX_SPEED_DPS)
            {
                captureFrameAsBlob().then(blob => {
                    if (blob) {
                        capturedImages.push(blob);
                        // Update `currentRotation` based on the absolute rotation achieved *at the time of capture*
                        currentRotation = currentAbsoluteRotation;
                        updateProgressIndicator(blob);
                        lastAlpha = alpha; // Store this alpha for next delta calculation
                        lastTimestamp = timestamp;

                        // Check for completion AFTER capturing the segment
                        if (capturedImages.length >= numSegments) {
                           // Check if total rotation is close enough to 360
                           if (currentRotation >= TARGET_ROTATION_DEGREES - (segmentAngle / 2)) {
                              endCapture();
                           }
                           // If not, maybe capture more if possible or just end.
                        }
                    }
                });
            }
             // Update lastAlpha and lastTimestamp regardless of capture trigger for smooth tracking
            lastAlpha = alpha;
            lastTimestamp = timestamp;
        }

        function updateTiltIndicator(beta) {
            let className = '';
            let instructionText = '';
            let tiltValue = beta; // beta is pitch, 0 is horizontal, positive is up, negative is down

            // Tweak threshold logic slightly: Make 'Aim slightly down' the default for slight downward tilt
            if (tiltValue < -TILT_DANGER_THRESHOLD || tiltValue > TILT_DANGER_THRESHOLD) {
                className = 'tilt-danger';
                 instructionText = tiltValue < 0 ? 'Point phone DOWN more' : 'Point phone UP more';
            } else if (tiltValue < -TILT_WARNING_THRESHOLD) { // Slight downward tilt
                className = 'tilt-warning';
                instructionText = 'Aim phone slightly DOWN';
            } else if (tiltValue > TILT_WARNING_THRESHOLD) { // Slight upward tilt
                 className = 'tilt-warning';
                 instructionText = 'Aim phone slightly UP';
            } else { // Neutral tilt
                 instructionText = 'Keep phone level';
            }

            tiltIndicator.className = className; // Apply danger/warning class
            tiltIndicator.querySelector('span').textContent = instructionText;
        }

        function updateSpeedIndicator(speed) {
            const speedLimit = MAX_SPEED_DPS;
            const percentage = Math.min(speed / speedLimit, 1); // Cap at 100%

            speedMeter.style.width = `${percentage * 100}%`;
            speedIndicatorText.textContent = `${Math.round(speed)}째/s`;

            if (speed > speedLimit) {
                speedMeter.style.backgroundColor = '#dc3545'; // Red
            } else if (speed > speedLimit * 0.7) {
                speedMeter.style.backgroundColor = '#ffc107'; // Amber
            } else {
                speedMeter.style.backgroundColor = '#28a745'; // Green
            }
        }


        // --- Capture Flow Control ---
        function startCaptureSequence() {
            if (!videoStream) {
                statusMessage.textContent = "Camera not ready. Please grant permissions.";
                return;
            }

            isCapturing = true;
            capturedImages = []; // Reset captures
            initialAlpha = null; // Reset orientation tracking
            lastAlpha = null;
            lastTimestamp = null;
            currentRotation = 0; // Reset cumulative rotation
            progressRect.style.width = '0%'; // Reset progress bar visual
            progressRect.innerHTML = ''; // Clear previous segments

            startCaptureButton.disabled = true;
            startCaptureButton.textContent = 'Capturing...';
            finalControlsDiv.style.display = 'none'; // Hide submit/retake initially
            instructionsText.textContent = "Start rotating slowly and steadily. Aim to cover 360 degrees.";
            statusMessage.textContent = ''; // Clear status

            // Prepare the high-res canvas
            setupHighResCanvas();

            // Add the first capture immediately
            captureFrameAsBlob().then(blob => {
                if (blob) {
                    capturedImages.push(blob);
                    // Set initial rotation based on first capture's orientation
                    currentRotation = (lastAlpha !== null ? Math.abs(lastAlpha - initialAlpha) : 0);
                    currentRotation = (currentRotation + 360) % 360;
                    updateProgressIndicator(blob);

                    // Now, start listening for orientation events and the animation loop
                    window.addEventListener('deviceorientation', handleOrientation, true);
                    animationFrameId = requestAnimationFrame(captureLoop);
                    statusMessage.textContent = 'Rotate now!';
                } else {
                     isCapturing = false;
                     statusMessage.textContent = "Failed to capture initial frame.";
                     startCaptureButton.disabled = false;
                     startCaptureButton.textContent = 'Start Capture';
                }
            });
        }

        function captureLoop() {
            if (!isCapturing) {
                return; // Stop the loop if capture is stopped
            }
            // The actual orientation handling and capture triggering happens in handleOrientation
            // This loop just ensures the process continues as long as isCapturing is true
            animationFrameId = requestAnimationFrame(captureLoop);
        }

        function endCapture() {
            isCapturing = false; // Stop the capture loop
            window.removeEventListener('deviceorientation', handleOrientation, true);
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            startCaptureButton.disabled = true;
            startCaptureButton.textContent = 'Capture Complete';
            finalControlsDiv.style.display = 'flex'; // Show submit/retake (flex for centering)
            instructionsText.textContent = "Capture complete! Review and submit, or retake.";
            statusMessage.textContent = 'Capture finished!';

             // Ensure the progress bar visually completes if slightly short
            const finalFilledWidth = Math.min((currentRotation / TARGET_ROTATION_DEGREES) * 100, 100);
            progressRect.style.width = `${finalFilledWidth}%`;
        }

        function submitCapture() {
            if (capturedImages.length === 0) {
                statusMessage.textContent = "No images captured yet.";
                return;
            }

            statusMessage.textContent = 'Uploading images...';
            submitCaptureButton.disabled = true;
            retakeCaptureButton.disabled = true;

            const formData = new FormData();
            capturedImages.forEach((blob, index) => {
                const filename = `capture_${String(index).padStart(3, '0')}.${IMAGE_FORMAT.split('/')[1]}`;
                formData.append('images', blob, filename);
            });

            formData.append('totalRotation', currentRotation);
            formData.append('numberOfImages', capturedImages.length);

            fetch(UPLOAD_URL, {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (response.ok) {
                    return response.json();
                } else {
                    throw new Error(`Server responded with status ${response.status}`);
                }
            })
            .then(data => {
                console.log('Upload successful:', data);
                statusMessage.textContent = 'Upload successful!';
                // Optionally clear captures or navigate away
            })
            .catch(error => {
                console.error('Upload failed:', error);
                statusMessage.textContent = `Upload failed: ${error.message}`;
                submitCaptureButton.disabled = false; // Re-enable on failure
                retakeCaptureButton.disabled = false;
            });
        }

        function retakeCapture() {
            // Stop any ongoing capture process
            isCapturing = false;
            window.removeEventListener('deviceorientation', handleOrientation, true);
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Reset state
            capturedImages = [];
            initialAlpha = null;
            lastAlpha = null;
            lastTimestamp = null;
            currentRotation = 0;

            // Reset UI
            progressRect.innerHTML = '';
            progressRect.style.width = '0%';
            tiltIndicator.className = ''; // Reset classes
            tiltIndicator.querySelector('span').textContent = 'Aim slightly down'; // Reset text
            speedMeter.style.width = '0%';
            speedIndicatorText.textContent = '0째/s';
            statusMessage.textContent = '';
            cameraPreview.style.display = 'none'; // Hide preview again
            cameraPreview.srcObject = null; // Stop the stream

            // Re-enable permission request flow
            startCaptureButton.disabled = false;
            startCaptureButton.textContent = 'Request Permissions';
            finalControlsDiv.style.display = 'none';

            // Reset instructions and status messages
            instructionsText.textContent = "Requesting camera permissions... Please grant access if prompted.";
            statusMessage.textContent = '';
            requestPermissions(); // Re-initiate permission request
        }

        // --- Initialization ---
        function init() {
            // Check for necessary APIs
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia || !window.DeviceOrientationEvent) {
                statusMessage.textContent = "This browser does not support required features (Camera API or Device Orientation).";
                instructionsText.textContent = "Please use a modern browser on a smartphone.";
                startCaptureButton.disabled = true;
                startCaptureButton.textContent = 'Unsupported';
                return;
            }

            // Add event listeners
            startCaptureButton.addEventListener('click', () => {
                if (startCaptureButton.textContent === 'Start Capture') {
                    startCaptureSequence();
                } else {
                    // This handles the initial permission request or retrying
                    requestPermissions();
                }
            });
            submitCaptureButton.addEventListener('click', submitCapture);
            retakeCaptureButton.addEventListener('click', retakeCapture);

            // Trigger initial permission request when the page loads
            requestPermissions();
        }

        // Initialize the app when the DOM is ready
        document.addEventListener('DOMContentLoaded', init);

    </script>

</body>
</html>
Citation Sources
https://github.com/ady24s/Dating-App 
https://github.com/julianGC78/Paixel-Front 
https://medium.com/@ric.kanjilal/rock-paper-sissor-game-with-simple-ai-with-just-javascript-html-css-cbdad4a82511 
https://www.vintasoft.com/docs/vsbarcode-dotnet-web/Programming-Barcode_Web-Tutorials-Recognize_barcodes_in_ASP.NET_Core_with_React.js_and_Redux.html 
User
next problem. the prompt says point phone up more. this doesn't change as I point the phone up. instead when I point it down the message changes to point is slightly up. when the phone is finally pointing at the floor then it says keep the phone level. I think you messed up the coordinates somehow.

AI
Thoughts
Expand to show model's summarized thoughts
You are absolutely right! Thank you for catching that. It seems the logic for interpreting the beta (pitch) angle and providing the correct corrective advice was indeed inverted.

The DeviceOrientationEvent specification defines beta such that:

beta = 0: Device is held level horizontally.
beta > 0: Device is tilted upwards (top of the device moves away from the ground).
beta < 0: Device is tilted downwards (top of the device moves towards the ground).
The original code's messages and conditions were not correctly mapping the beta value to the necessary correction. If the phone is tilted too far up (beta > 0), the correction is to point it down. If it's tilted too far down (beta < 0), the correction is to point it up.

I've corrected the updateTiltIndicator function in the code below to reflect this logic and provide clearer instructions.

Here is the complete, updated index.html file:

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360 Capture Guide</title>
    <style>
        /* Basic Reset & Body Styling */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* justify-content: center; REMOVED: This caused content to be pushed off-screen */
            min-height: 100vh; /* Still ensure background fills viewport */
            margin: 0;
            background-color: #f0f0f0;
            color: #333;
            overflow-x: hidden; /* Prevent horizontal scroll */
            box-sizing: border-box;
            padding-bottom: 20px; /* Add some space at the bottom */
        }

        /* Styles for the main content wrapper */
        .content-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%; /* Take available width */
            max-width: 600px; /* Set a consistent max-width for main content */
            padding: 0 15px; /* Add horizontal padding so content isn't edge-to-edge */
            box-sizing: border-box; /* Include padding in width calculation */
            flex-grow: 1; /* Allow wrapper to grow if needed */
        }

        /* Camera Preview */
        #camera-preview {
            width: 100%;
            max-width: 600px; /* Match wrapper max-width */
            height: auto;
            aspect-ratio: 4 / 3; /* Maintain aspect ratio */
            background-color: #ccc;
            border: 2px solid #555;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transform: scaleX(-1); /* Mirror the preview */
            display: none; /* Hidden until stream is ready */
            object-fit: cover; /* Ensure video fills the aspect ratio */
            margin-bottom: 15px; /* Add space below preview */
        }

        /* Instructions and Status */
        #instructions, #status-message {
            margin: 10px 0; /* Reduce margin */
            text-align: center;
            font-size: 1.1em;
            line-height: 1.5;
        }
        #status-message {
            font-weight: bold;
            color: #007bff;
        }

        /* Buttons */
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            font-size: 1.1em;
            cursor: pointer;
            margin: 10px 5px;
            transition: background-color 0.3s ease;
            width: 90%; /* Make buttons wider */
            max-width: 300px; /* Limit button width */
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        /* Progress Indicator Area */
        #progress-area {
            width: 100%;
            max-width: 600px; /* Match wrapper max-width */
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px; /* Add space above the progress area */
        }

        #progress-container {
            width: 100%;
            height: 60px; /* Fixed height for the progress bar */
            background-color: white;
            border: 2px solid #ccc;
            display: flex;
            overflow: hidden; /* Important to clip child elements */
            position: relative; /* For absolute positioning of elements if needed */
            border-radius: 5px;
            margin-bottom: 10px;
        }

        #progress-rect {
            height: 100%;
            background: linear-gradient(to right, #e0e0e0, #f8f8f8); /* Subtle gradient */
            display: flex; /* Use flex for image segments */
            transition: width 0.2s ease-out; /* Smoothly expand the filled part */
        }

        .progress-segment {
            height: 100%;
            flex-shrink: 0; /* Prevent shrinking */
            object-fit: cover; /* Ensure image covers segment area */
            background-color: #eee; /* Placeholder color */
            border-right: 1px solid #ddd; /* Visual separator */
        }
        .progress-segment:last-child {
            border-right: none;
        }


        /* Tilt Indicator */
        #tilt-indicator {
            width: 100%; /* Make it fill the wrapper width */
            height: 30px;
            background-color: rgba(255, 255, 255, 0.7);
            border: 1px solid #aaa;
            margin: 10px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            position: relative;
        }
        #tilt-indicator::before,
        #tilt-indicator::after {
            content: '';
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 5px;
            height: 20px;
            background-color: #ccc; /* Default neutral color */
            border-radius: 3px;
        }
        #tilt-indicator::before {
            left: 25%;
        }
        #tilt-indicator::after {
            right: 25%;
        }
        .tilt-warning {
            background-color: rgba(255, 193, 7, 0.7); /* Amber */
        }
        .tilt-warning::before,
        .tilt-warning::after {
            background-color: #ffc107; /* Amber indicator */
        }
        .tilt-danger {
             background-color: rgba(220, 53, 69, 0.7); /* Red */
        }
        .tilt-danger::before,
        .tilt-danger::after {
             background-color: #dc3545; /* Red indicator */
        }
        #tilt-indicator span {
            font-size: 0.9em;
            font-weight: bold;
            color: #555;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }


        /* Speed Indicator */
        #speed-indicator {
            width: 100%; /* Make it fill the wrapper width */
            height: 25px;
            background-color: #e0e0e0;
            border-radius: 5px;
            margin-top: 5px;
            position: relative;
            overflow: hidden;
        }
        #speed-meter {
            height: 100%;
            width: 0%;
            background-color: #28a745; /* Green */
            transition: width 0.2s ease-out;
        }
        #speed-indicator-text {
             position: absolute;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             font-size: 0.8em;
             color: white;
             font-weight: bold;
             text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
        }

        /* Final Controls */
        #final-controls {
            display: none; /* Hidden until capture is complete */
            margin-top: 20px;
            width: 100%; /* Ensure controls take full width */
            display: flex;
            justify-content: center; /* Center buttons within this div */
            flex-wrap: wrap; /* Allow buttons to wrap on small screens */
        }
        #final-controls button {
            width: 45%; /* Make buttons take up roughly half the width */
            max-width: 200px; /* Limit width */
        }


        /* Media Queries for smaller screens */
        @media (max-width: 768px) {
            /* Adjust padding for wrapper if needed */
            .content-wrapper {
                padding: 0 10px; /* Slightly less padding on very small screens */
            }

            #camera-preview {
                aspect-ratio: 1 / 1; /* Different aspect ratio on smaller screens */
                margin-bottom: 10px; /* Reduce margin */
            }
            #instructions, #status-message {
                 font-size: 1em;
                 margin: 5px 0; /* Reduce margins further */
            }
            #progress-area {
                margin-top: 10px; /* Reduce margin */
            }
            button {
                margin: 5px 5px; /* Reduce button margins */
                font-size: 1em; /* Slightly smaller font */
                padding: 10px 20px;
            }
            /* Adjust indicators to fill width better */
            #tilt-indicator, #speed-indicator {
                width: 100%; /* Ensure they use wrapper width */
                max-width: none; /* Remove max-width constraint */
            }
            #final-controls button {
                 width: 90%; /* Make buttons stack vertically on very small screens */
                 max-width: 300px;
            }
        }
    </style>
</head>
<body>

    <div class="content-wrapper">
        <h1>360 Photo Capture</h1>

        <video id="camera-preview" autoplay playsinline muted></video>

        <p id="instructions">
            Requesting camera permissions... Please grant access if prompted.
        </p>

        <button id="start-capture">Request Permissions</button>

        <div id="progress-area">
            <div id="progress-container">
                <div id="progress-rect">
                    <!-- Image segments will be appended here -->
                </div>
            </div>
            <div id="tilt-indicator">
                <span>Keep phone level</span>
                <!-- Indicators change based on tilt -->
            </div>
            <div id="speed-indicator">
                <div id="speed-meter"></div>
                <div id="speed-indicator-text">0째/s</div>
            </div>
        </div>

        <div id="final-controls">
            <button id="submit-capture">Submit</button>
            <button id="retake-capture">Retake</button>
        </div>

        <p id="status-message"></p>
    </div>

    <script>
        // --- Configuration ---
        const TARGET_ROTATION_DEGREES = 360;
        const OVERLAP_DEGREES = 20; // Each image overlaps the previous one by this amount
        const MAX_SPEED_DPS = 45; // Max degrees per second to avoid blur (adjust as needed)
        // TILT Thresholds: beta=0 is level. Positive beta is UP, Negative beta is DOWN.
        const TILT_WARNING_THRESHOLD = 15; // Degrees deviation from horizontal for warning
        const TILT_DANGER_THRESHOLD = 30; // Degrees deviation from horizontal for danger
        const HIGH_RES_WIDTH = 3840;
        const HIGH_RES_HEIGHT = 2160;
        const IMAGE_FORMAT = 'image/jpeg';
        const IMAGE_QUALITY = 0.92;
        const UPLOAD_URL = '/api/upload-360-images'; // Placeholder URL

        // --- DOM Elements ---
        const cameraPreview = document.getElementById('camera-preview');
        const startCaptureButton = document.getElementById('start-capture');
        const submitCaptureButton = document.getElementById('submit-capture');
        const retakeCaptureButton = document.getElementById('retake-capture');
        const instructionsText = document.getElementById('instructions');
        const statusMessage = document.getElementById('status-message');
        const progressRect = document.getElementById('progress-rect');
        const tiltIndicator = document.getElementById('tilt-indicator');
        const speedMeter = document.getElementById('speed-meter');
        const speedIndicatorText = document.getElementById('speed-indicator-text');
        const finalControlsDiv = document.getElementById('final-controls');

        // --- State Variables ---
        let videoStream = null;
        let highResCanvas = null;
        let highResCtx = null;
        let capturedImages = []; // Array to store image Blobs
        let isCapturing = false;
        let initialAlpha = null; // Alpha angle at the start of capture
        let lastAlpha = null;
        let lastTimestamp = null;
        let currentRotation = 0; // Tracks the total degrees covered by captured segments
        let animationFrameId = null;
        // Calculate number of segments needed based on overlap
        let numSegments = Math.ceil(TARGET_ROTATION_DEGREES / (TARGET_ROTATION_DEGREES / Math.ceil(TARGET_ROTATION_DEGREES / OVERLAP_DEGREES)));
        let segmentWidthPx = 0;

        // --- Permissions ---
        async function requestPermissions() {
            statusMessage.textContent = 'Requesting camera access...';
            instructionsText.textContent = 'Please grant camera permission when prompted.';
            startCaptureButton.disabled = true;
            startCaptureButton.textContent = 'Requesting...';

            try {
                // Request camera permission
                videoStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: HIGH_RES_WIDTH },
                        height: { ideal: HIGH_RES_HEIGHT },
                        frameRate: { ideal: 30 }
                    },
                    audio: false
                });

                cameraPreview.srcObject = videoStream;
                cameraPreview.style.display = 'block';
                statusMessage.textContent = 'Camera ready. Stand by...';

                await new Promise((resolve) => {
                    cameraPreview.onloadedmetadata = resolve;
                });

                // Request Device Orientation permission (especially for iOS)
                if (typeof DeviceOrientationEvent !== 'undefined' && DeviceOrientationEvent.requestPermission) {
                    const permissionState = await DeviceOrientationEvent.requestPermission();
                    if (permissionState === 'granted') {
                         statusMessage.textContent = 'Camera & Motion permissions granted. Ready to start.';
                         instructionsText.textContent = "Identify a starting feature. Hold your phone vertically. Tap 'Start Capture' when ready.";
                         startCaptureButton.disabled = false;
                         startCaptureButton.textContent = 'Start Capture';
                    } else {
                        throw new Error("Motion and orientation access denied.");
                    }
                } else {
                     statusMessage.textContent = 'Camera permission granted. Ready to start.';
                     instructionsText.textContent = "Identify a starting feature. Hold your phone vertically. Tap 'Start Capture' when ready.";
                     startCaptureButton.disabled = false;
                     startCaptureButton.textContent = 'Start Capture';
                }
                return true;

            } catch (err) {
                console.error("Error accessing media devices or permissions:", err);
                let userMessage = `Error: ${err.message}. Please ensure camera/motion permissions are granted in your browser settings.`;
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                     userMessage = "Permission denied. Please grant camera and motion access in your browser's site settings for this page.";
                } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                     userMessage = "Camera not found. Please ensure your device has a working camera.";
                } else if (err.message.includes("motion and orientation access denied")) {
                    userMessage = "Motion and orientation access denied. Please grant permission for motion sensors.";
                }
                statusMessage.textContent = userMessage;
                instructionsText.textContent = "Please grant permissions via browser settings.";
                startCaptureButton.disabled = false;
                startCaptureButton.textContent = 'Retry Permissions';
                return false;
            }
        }

        // --- High-Resolution Capture ---
        function setupHighResCanvas() {
            if (!highResCanvas) {
                highResCanvas = document.createElement('canvas');
                highResCtx = highResCanvas.getContext('2d');
            }
            // Set canvas dimensions to match the video stream's actual dimensions
            highResCanvas.width = cameraPreview.videoWidth || HIGH_RES_WIDTH;
            highResCanvas.height = cameraPreview.videoHeight || HIGH_RES_HEIGHT;
        }

        function captureFrameAsBlob() {
            if (!highResCanvas || !highResCtx || !isCapturing) return null;

            setupHighResCanvas();

            // Draw the current video frame onto the canvas, correcting for mirroring
            highResCtx.save();
            highResCtx.scale(-1, 1); // Mirror context horizontally
            // Draw mirrored frame to the canvas at the correct position (-width, 0)
            highResCtx.drawImage(cameraPreview, -highResCanvas.width, 0, highResCanvas.width, highResCanvas.height);
            highResCtx.restore();

            return new Promise(resolve => {
                highResCanvas.toBlob(blob => {
                    resolve(blob);
                }, IMAGE_FORMAT, IMAGE_QUALITY);
            });
        }

        // --- Progress Indicator Management ---
        function updateProgressIndicator(imageBlob) {
            if (!imageBlob) return;

            const segmentIndex = capturedImages.length - 1;
            const segmentAngle = TARGET_ROTATION_DEGREES / numSegments;
            const segmentWidthRatio = segmentAngle / TARGET_ROTATION_DEGREES;

            const segmentCanvas = document.createElement('canvas');
            segmentCanvas.className = 'progress-segment';
            segmentCanvas.style.width = `${segmentWidthRatio * 100}%`;

            const segmentCtx = segmentCanvas.getContext('2d');
            const img = new Image();
            img.onload = () => {
                // Scale image to fit the segment while maintaining aspect ratio
                const segmentAspectRatio = segmentCanvas.width / segmentCanvas.height;
                const imageAspectRatio = img.width / img.height;

                let drawWidth, drawHeight, drawX, drawY;

                if (imageAspectRatio > segmentAspectRatio) { // Image is wider than segment aspect ratio
                    drawWidth = segmentCanvas.width;
                    drawHeight = segmentCanvas.width / imageAspectRatio;
                    drawX = 0;
                    drawY = (segmentCanvas.height - drawHeight) / 2; // Center vertically
                } else { // Image is taller than segment aspect ratio
                    drawHeight = segmentCanvas.height;
                    drawWidth = segmentCanvas.height * imageAspectRatio;
                    drawY = 0;
                    drawX = (segmentCanvas.width - drawWidth) / 2; // Center horizontally
                }
                segmentCtx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
            };
            img.src = URL.createObjectURL(imageBlob);

            progressRect.appendChild(segmentCanvas);

            // Update the filled width of the progress bar visually based on cumulative rotation
            const filledWidthPercentage = Math.min((currentRotation / TARGET_ROTATION_DEGREES) * 100, 100);
            progressRect.style.width = `${filledWidthPercentage}%`;
        }

        // --- Orientation Handling & Tilt Feedback ---
        function updateTiltIndicator(beta) {
            let className = '';
            let instructionText = '';
            let tiltValue = beta; // beta is pitch, 0 is horizontal, positive is up, negative is down

            // Check for danger levels first
            if (tiltValue > TILT_DANGER_THRESHOLD) { // Too far UP
                className = 'tilt-danger';
                instructionText = 'Aim phone DOWN'; // Correction: point DOWN
            } else if (tiltValue < -TILT_DANGER_THRESHOLD) { // Too far DOWN
                className = 'tilt-danger';
                instructionText = 'Aim phone UP'; // Correction: point UP
            }
            // Check for warning levels if not in danger
            else if (tiltValue > TILT_WARNING_THRESHOLD) { // Slightly UP
                className = 'tilt-warning';
                instructionText = 'Aim phone slightly UP'; // Gentle correction: point slightly DOWN
            } else if (tiltValue < -TILT_WARNING_THRESHOLD) { // Slightly DOWN
                className = 'tilt-warning';
                instructionText = 'Aim phone slightly DOWN'; // Gentle correction: point slightly UP
            }
            // Neutral zone
            else {
                instructionText = 'Keep phone level';
            }

            tiltIndicator.className = className; // Apply danger/warning class
            tiltIndicator.querySelector('span').textContent = instructionText;
        }

        // --- Speed Feedback ---
        function updateSpeedIndicator(speed) {
            const speedLimit = MAX_SPEED_DPS;
            const percentage = Math.min(speed / speedLimit, 1); // Cap at 100%

            speedMeter.style.width = `${percentage * 100}%`;
            speedIndicatorText.textContent = `${Math.round(speed)}째/s`;

            if (speed > speedLimit) {
                speedMeter.style.backgroundColor = '#dc3545'; // Red
            } else if (speed > speedLimit * 0.7) {
                speedMeter.style.backgroundColor = '#ffc107'; // Amber
            } else {
                speedMeter.style.backgroundColor = '#28a745'; // Green
            }
        }

        // --- Orientation Event Handler ---
        function handleOrientation(event) {
            if (!isCapturing || !event.alpha || !event.beta || !event.gamma) return;

            const alpha = event.alpha; // Rotation around Z axis (left-right turn)
            const beta = event.beta;   // Rotation around X axis (up-down tilt)
            const gamma = event.gamma; // Rotation around Y axis (left-right tilt)
            const timestamp = performance.now();

            // Initialize on first reading after capture starts
            if (initialAlpha === null) {
                initialAlpha = alpha;
                lastAlpha = alpha;
                lastTimestamp = timestamp;
                updateTiltIndicator(beta); // Update tilt based on initial orientation
                return;
            }

            // Calculate rotation delta from the *last recorded orientation*
            let deltaAlpha = alpha - lastAlpha;

            // Handle angle wrap-around (e.g., 359 -> 1 degree)
            if (deltaAlpha > 180) deltaAlpha -= 360;
            if (deltaAlpha < -180) deltaAlpha += 360;

            const deltaTime = timestamp - lastTimestamp;
            // Avoid division by zero if timestamp is the same
            const rotationSpeed = (deltaTime > 0) ? Math.abs(deltaAlpha) / (deltaTime / 1000) : 0; // Degrees per second

            // Update speed indicator
            updateSpeedIndicator(rotationSpeed);

            // Update tilt indicator
            updateTiltIndicator(beta);

            // Calculate current absolute rotation relative to the start
            let currentAbsoluteRotation = alpha - initialAlpha;
            // Normalize to 0-360 degrees range
            if (currentAbsoluteRotation > 180) currentAbsoluteRotation -= 360;
            if (currentAbsoluteRotation < -180) currentAbsoluteRotation += 360;
            currentAbsoluteRotation = (currentAbsoluteRotation + 360) % 360;

            // --- Capture Condition ---
            const segmentAngle = TARGET_ROTATION_DEGREES / numSegments;
            // Determine the angle needed to trigger the next capture, based on previous capture point
            let angleMovedSinceLastCapture = 0;
            if (lastAlpha !== null) {
                angleMovedSinceLastCapture = alpha - lastAlpha;
                if (angleMovedSinceLastCapture > 180) angleMovedSinceLastCapture -= 360;
                if (angleMovedSinceLastCapture < -180) angleMovedSinceLastCapture += 360;
                angleMovedSinceLastCapture = Math.abs(angleMovedSinceLastCapture);
            } else { // For the very first capture after the initial one
                 angleMovedSinceLastCapture = Math.abs(alpha - initialAlpha);
                 if (angleMovedSinceLastCapture > 180) angleMovedSinceLastCapture -= 360;
                 if (angleMovedSinceLastCapture < -180) angleMovedSinceLastCapture += 360;
                 angleMovedSinceLastCapture = Math.abs(angleMovedSinceLastCapture);
            }

            // Trigger capture if:
            // 1. We still need more segments (`capturedImages.length < numSegments`)
            // 2. We have rotated enough since the last capture trigger (to ensure sufficient overlap).
            // 3. The rotation speed is acceptable.
            const captureTriggerAngle = (capturedImages.length === 0) ? segmentAngle / 2 : segmentAngle; // Capture first image after half a segment's rotation from start

            if (capturedImages.length < numSegments &&
                angleMovedSinceLastCapture >= captureTriggerAngle &&
                rotationSpeed < MAX_SPEED_DPS)
            {
                captureFrameAsBlob().then(blob => {
                    if (blob) {
                        capturedImages.push(blob);
                        // Update `currentRotation` based on the absolute rotation achieved *at the time of capture*
                        currentRotation = currentAbsoluteRotation;
                        updateProgressIndicator(blob);
                        lastAlpha = alpha; // Store this alpha for next delta calculation
                        lastTimestamp = timestamp;

                        // Check for completion AFTER capturing the segment
                        if (capturedImages.length >= numSegments) {
                           // Ensure total rotation is close enough to 360 degrees
                           if (currentRotation >= TARGET_ROTATION_DEGREES - (segmentAngle / 2)) {
                              endCapture();
                           }
                        }
                    }
                });
            }
            // Update lastAlpha and lastTimestamp regardless of capture trigger for smooth tracking
            lastAlpha = alpha;
            lastTimestamp = timestamp;
        }

        // --- Capture Flow Control ---
        function startCaptureSequence() {
            if (!videoStream) {
                statusMessage.textContent = "Camera not ready. Please grant permissions.";
                return;
            }

            isCapturing = true;
            capturedImages = []; // Reset captures
            initialAlpha = null; // Reset orientation tracking
            lastAlpha = null;
            lastTimestamp = null;
            currentRotation = 0; // Reset cumulative rotation
            progressRect.style.width = '0%'; // Reset progress bar visual
            progressRect.innerHTML = ''; // Clear previous segments

            startCaptureButton.disabled = true;
            startCaptureButton.textContent = 'Capturing...';
            finalControlsDiv.style.display = 'none'; // Hide submit/retake initially
            instructionsText.textContent = "Start rotating slowly and steadily. Aim to cover 360 degrees.";
            statusMessage.textContent = ''; // Clear status

            // Prepare the high-res canvas
            setupHighResCanvas();

            // Add the first capture immediately
            captureFrameAsBlob().then(blob => {
                if (blob) {
                    capturedImages.push(blob);
                    // Set initial rotation based on first capture's orientation (relative to start)
                    currentRotation = (lastAlpha !== null ? Math.abs(lastAlpha - initialAlpha) : 0);
                    currentRotation = (currentRotation + 360) % 360; // Normalize to 0-360
                    updateProgressIndicator(blob);

                    // Now, start listening for orientation events and the animation loop
                    window.addEventListener('deviceorientation', handleOrientation, true);
                    animationFrameId = requestAnimationFrame(captureLoop);
                    statusMessage.textContent = 'Rotate now!';
                } else {
                     isCapturing = false;
                     statusMessage.textContent = "Failed to capture initial frame.";
                     startCaptureButton.disabled = false;
                     startCaptureButton.textContent = 'Start Capture';
                }
            });
        }

        function captureLoop() {
            if (!isCapturing) {
                return; // Stop the loop if capture is stopped
            }
            // The actual orientation handling and capture triggering happens in handleOrientation
            animationFrameId = requestAnimationFrame(captureLoop);
        }

        function endCapture() {
            isCapturing = false; // Stop the capture loop
            window.removeEventListener('deviceorientation', handleOrientation, true);
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            startCaptureButton.disabled = true;
            startCaptureButton.textContent = 'Capture Complete';
            finalControlsDiv.style.display = 'flex'; // Show submit/retake (flex for centering)
            instructionsText.textContent = "Capture complete! Review and submit, or retake.";
            statusMessage.textContent = 'Capture finished!';

             // Ensure the progress bar visually completes if slightly short
            const finalFilledWidth = Math.min((currentRotation / TARGET_ROTATION_DEGREES) * 100, 100);
            progressRect.style.width = `${finalFilledWidth}%`;
        }

        function submitCapture() {
            if (capturedImages.length === 0) {
                statusMessage.textContent = "No images captured yet.";
                return;
            }

            statusMessage.textContent = 'Uploading images...';
            submitCaptureButton.disabled = true;
            retakeCaptureButton.disabled = true;

            const formData = new FormData();
            capturedImages.forEach((blob, index) => {
                const filename = `capture_${String(index).padStart(3, '0')}.${IMAGE_FORMAT.split('/')[1]}`;
                formData.append('images', blob, filename);
            });

            formData.append('totalRotation', currentRotation);
            formData.append('numberOfImages', capturedImages.length);

            fetch(UPLOAD_URL, {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (response.ok) {
                    return response.json(); // Assuming server responds with JSON
                } else {
                    throw new Error(`Server responded with status ${response.status}`);
                }
            })
            .then(data => {
                console.log('Upload successful:', data);
                statusMessage.textContent = 'Upload successful!';
            })
            .catch(error => {
                console.error('Upload failed:', error);
                statusMessage.textContent = `Upload failed: ${error.message}`;
                submitCaptureButton.disabled = false; // Re-enable on failure
                retakeCaptureButton.disabled = false;
            });
        }

        function retakeCapture() {
            // Stop any ongoing capture process
            isCapturing = false;
            window.removeEventListener('deviceorientation', handleOrientation, true);
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Reset state
            capturedImages = [];
            initialAlpha = null;
            lastAlpha = null;
            lastTimestamp = null;
            currentRotation = 0;

            // Reset UI
            progressRect.innerHTML = '';
            progressRect.style.width = '0%';
            tiltIndicator.className = ''; // Reset classes
            tiltIndicator.querySelector('span').textContent = 'Keep phone level'; // Reset text
            speedMeter.style.width = '0%';
            speedIndicatorText.textContent = '0째/s';
            statusMessage.textContent = '';
            cameraPreview.style.display = 'none'; // Hide preview again
            cameraPreview.srcObject = null; // Stop the stream

            // Re-enable permission request flow
            startCaptureButton.disabled = false;
            startCaptureButton.textContent = 'Request Permissions';
            finalControlsDiv.style.display = 'none';

            // Reset instructions and status messages
            instructionsText.textContent = "Requesting camera permissions... Please grant access if prompted.";
            statusMessage.textContent = '';
            requestPermissions(); // Re-initiate permission request
        }

        // --- Initialization ---
        function init() {
            // Check for necessary APIs
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia || !window.DeviceOrientationEvent) {
                statusMessage.textContent = "This browser does not support required features (Camera API or Device Orientation).";
                instructionsText.textContent = "Please use a modern browser on a smartphone.";
                startCaptureButton.disabled = true;
                startCaptureButton.textContent = 'Unsupported';
                return;
            }

            // Add event listeners
            startCaptureButton.addEventListener('click', () => {
                // Check the button text to decide action: request permissions or start capture
                if (startCaptureButton.textContent === 'Start Capture') {
                    startCaptureSequence();
                } else {
                    // This handles the initial permission request or retrying after denial
                    requestPermissions();
                }
            });
            submitCaptureButton.addEventListener('click', submitCapture);
            retakeCaptureButton.addEventListener('click', retakeCapture);

            // Trigger initial permission request when the page loads
            requestPermissions();
        }

        // Initialize the app when the DOM is ready
        document.addEventListener('DOMContentLoaded', init);

    </script>

</body>
</html>
