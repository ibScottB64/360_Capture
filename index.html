<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360 Capture Guide</title>
    <style>
        /* Basic Reset & Body Styling */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* justify-content: center; REMOVED: This caused content to be pushed off-screen */
            min-height: 100vh; /* Still ensure background fills viewport */
            margin: 0;
            background-color: #f0f0f0;
            color: #333;
            overflow-x: hidden; /* Prevent horizontal scroll */
            box-sizing: border-box;
            padding-bottom: 20px; /* Add some space at the bottom */
        }

        /* Styles for the main content wrapper */
        .content-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%; /* Take available width */
            max-width: 600px; /* Set a consistent max-width for main content */
            padding: 0 15px; /* Add horizontal padding so content isn't edge-to-edge */
            box-sizing: border-box; /* Include padding in width calculation */
            flex-grow: 1; /* Allow wrapper to grow if needed */
        }

        /* Camera Preview */
        #camera-preview {
            width: 100%;
            max-width: 600px; /* Match wrapper max-width */
            height: auto;
            aspect-ratio: 4 / 3; /* Maintain aspect ratio */
            background-color: #ccc;
            border: 2px solid #555;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transform: scaleX(-1); /* Mirror the preview */
            display: none; /* Hidden until stream is ready */
            object-fit: cover; /* Ensure video fills the aspect ratio */
            margin-bottom: 15px; /* Add space below preview */
        }

        /* Instructions and Status */
        #instructions, #status-message {
            margin: 10px 0; /* Reduce margin */
            text-align: center;
            font-size: 1.1em;
            line-height: 1.5;
        }
        #status-message {
            font-weight: bold;
            color: #007bff;
        }

        /* Buttons */
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            font-size: 1.1em;
            cursor: pointer;
            margin: 10px 5px;
            transition: background-color 0.3s ease;
            width: 90%; /* Make buttons wider */
            max-width: 300px; /* Limit button width */
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        /* Progress Indicator Area */
        #progress-area {
            width: 100%;
            max-width: 600px; /* Match wrapper max-width */
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px; /* Add space above the progress area */
        }

        #progress-container {
            width: 100%;
            height: 60px; /* Fixed height for the progress bar */
            background-color: white;
            border: 2px solid #ccc;
            display: flex;
            overflow: hidden; /* Important to clip child elements */
            position: relative; /* For absolute positioning of elements if needed */
            border-radius: 5px;
            margin-bottom: 10px;
        }

        #progress-rect {
            height: 100%;
            background: linear-gradient(to right, #e0e0e0, #f8f8f8); /* Subtle gradient */
            display: flex; /* Use flex for image segments */
            transition: width 0.2s ease-out; /* Smoothly expand the filled part */
        }

        .progress-segment {
            height: 100%;
            flex-shrink: 0; /* Prevent shrinking */
            object-fit: cover; /* Ensure image covers segment area */
            background-color: #eee; /* Placeholder color */
            border-right: 1px solid #ddd; /* Visual separator */
        }
        .progress-segment:last-child {
            border-right: none;
        }


        /* Tilt Indicator */
        #tilt-indicator {
            width: 100%; /* Make it fill the wrapper width */
            height: 30px;
            background-color: rgba(255, 255, 255, 0.7);
            border: 1px solid #aaa;
            margin: 10px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            position: relative;
        }
        #tilt-indicator::before,
        #tilt-indicator::after {
            content: '';
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 5px;
            height: 20px;
            background-color: #ccc; /* Default neutral color */
            border-radius: 3px;
        }
        #tilt-indicator::before {
            left: 25%;
        }
        #tilt-indicator::after {
            right: 25%;
        }
        .tilt-warning {
            background-color: rgba(255, 193, 7, 0.7); /* Amber */
        }
        .tilt-warning::before,
        .tilt-warning::after {
            background-color: #ffc107; /* Amber indicator */
        }
        .tilt-danger {
             background-color: rgba(220, 53, 69, 0.7); /* Red */
        }
        .tilt-danger::before,
        .tilt-danger::after {
             background-color: #dc3545; /* Red indicator */
        }
        #tilt-indicator span {
            font-size: 0.9em;
            font-weight: bold;
            color: #555;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }


        /* Speed Indicator */
        #speed-indicator {
            width: 100%; /* Make it fill the wrapper width */
            height: 25px;
            background-color: #e0e0e0;
            border-radius: 5px;
            margin-top: 5px;
            position: relative;
            overflow: hidden;
        }
        #speed-meter {
            height: 100%;
            width: 0%;
            background-color: #28a745; /* Green */
            transition: width 0.2s ease-out;
        }
        #speed-indicator-text {
             position: absolute;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             font-size: 0.8em;
             color: white;
             font-weight: bold;
             text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
        }

        /* Final Controls */
        #final-controls {
            display: none; /* Hidden until capture is complete */
            margin-top: 20px;
            width: 100%; /* Ensure controls take full width */
            display: flex;
            justify-content: center; /* Center buttons within this div */
            flex-wrap: wrap; /* Allow buttons to wrap on small screens */
        }
        #final-controls button {
            width: 45%; /* Make buttons take up roughly half the width */
            max-width: 200px; /* Limit width */
        }


        /* Media Queries for smaller screens */
        @media (max-width: 768px) {
            /* Adjust padding for wrapper if needed */
            .content-wrapper {
                padding: 0 10px; /* Slightly less padding on very small screens */
            }

            #camera-preview {
                aspect-ratio: 1 / 1; /* Different aspect ratio on smaller screens */
                margin-bottom: 10px; /* Reduce margin */
            }
            #instructions, #status-message {
                 font-size: 1em;
                 margin: 5px 0; /* Reduce margins further */
            }
            #progress-area {
                margin-top: 10px; /* Reduce margin */
            }
            button {
                margin: 5px 5px; /* Reduce button margins */
                font-size: 1em; /* Slightly smaller font */
                padding: 10px 20px;
            }
            /* Adjust indicators to fill width better */
            #tilt-indicator, #speed-indicator {
                width: 100%; /* Ensure they use wrapper width */
                max-width: none; /* Remove max-width constraint */
            }
            #final-controls button {
                 width: 90%; /* Make buttons stack vertically on very small screens */
                 max-width: 300px;
            }
        }
    </style>
</head>
<body>

    <div class="content-wrapper">
        <h1>360 Photo Capture</h1>

        <video id="camera-preview" autoplay playsinline muted></video>

        <p id="instructions">
            Requesting camera permissions... Please grant access if prompted.
        </p>

        <button id="start-capture">Request Permissions</button>

        <div id="progress-area">
            <div id="progress-container">
                <div id="progress-rect">
                    <!-- Image segments will be appended here -->
                </div>
            </div>
            <div id="tilt-indicator">
                <span>Keep phone level</span>
                <!-- Indicators change based on tilt -->
            </div>
            <div id="speed-indicator">
                <div id="speed-meter"></div>
                <div id="speed-indicator-text">0°/s</div>
            </div>
        </div>

        <div id="final-controls">
            <button id="submit-capture">Submit</button>
            <button id="retake-capture">Retake</button>
        </div>

        <p id="status-message"></p>
    </div>

    <script>
        // --- Configuration ---
        const TARGET_ROTATION_DEGREES = 360;
        const OVERLAP_DEGREES = 20; // Each image overlaps the previous one by this amount
        const MAX_SPEED_DPS = 45; // Max degrees per second to avoid blur (adjust as needed)
        // TILT Thresholds: beta=0 is level. Positive beta is UP, Negative beta is DOWN.
        const TILT_WARNING_THRESHOLD = 15; // Degrees deviation from horizontal for warning
        const TILT_DANGER_THRESHOLD = 30; // Degrees deviation from horizontal for danger
        const HIGH_RES_WIDTH = 3840;
        const HIGH_RES_HEIGHT = 2160;
        const IMAGE_FORMAT = 'image/jpeg';
        const IMAGE_QUALITY = 0.92;
        const UPLOAD_URL = '/api/upload-360-images'; // Placeholder URL

        // --- DOM Elements ---
        const cameraPreview = document.getElementById('camera-preview');
        const startCaptureButton = document.getElementById('start-capture');
        const submitCaptureButton = document.getElementById('submit-capture');
        const retakeCaptureButton = document.getElementById('retake-capture');
        const instructionsText = document.getElementById('instructions');
        const statusMessage = document.getElementById('status-message');
        const progressRect = document.getElementById('progress-rect');
        const tiltIndicator = document.getElementById('tilt-indicator');
        const speedMeter = document.getElementById('speed-meter');
        const speedIndicatorText = document.getElementById('speed-indicator-text');
        const finalControlsDiv = document.getElementById('final-controls');

        // --- State Variables ---
        let videoStream = null;
        let highResCanvas = null;
        let highResCtx = null;
        let capturedImages = []; // Array to store image Blobs
        let isCapturing = false;
        let initialAlpha = null; // Alpha angle at the start of capture
        let lastAlpha = null;
        let lastTimestamp = null;
        let currentRotation = 0; // Tracks the total degrees covered by captured segments
        let animationFrameId = null;
        // Calculate number of segments needed based on overlap
        let numSegments = Math.ceil(TARGET_ROTATION_DEGREES / (TARGET_ROTATION_DEGREES / Math.ceil(TARGET_ROTATION_DEGREES / OVERLAP_DEGREES)));
        let segmentWidthPx = 0;

        // --- Permissions ---
        async function requestPermissions() {
            statusMessage.textContent = 'Requesting camera access...';
            instructionsText.textContent = 'Please grant camera permission when prompted.';
            startCaptureButton.disabled = true;
            startCaptureButton.textContent = 'Requesting...';

            try {
                // Request camera permission
                videoStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: HIGH_RES_WIDTH },
                        height: { ideal: HIGH_RES_HEIGHT },
                        frameRate: { ideal: 30 }
                    },
                    audio: false
                });

                cameraPreview.srcObject = videoStream;
                cameraPreview.style.display = 'block';
                statusMessage.textContent = 'Camera ready. Stand by...';

                await new Promise((resolve) => {
                    cameraPreview.onloadedmetadata = resolve;
                });

                // Request Device Orientation permission (especially for iOS)
                if (typeof DeviceOrientationEvent !== 'undefined' && DeviceOrientationEvent.requestPermission) {
                    const permissionState = await DeviceOrientationEvent.requestPermission();
                    if (permissionState === 'granted') {
                         statusMessage.textContent = 'Camera & Motion permissions granted. Ready to start.';
                         instructionsText.textContent = "Identify a starting feature. Hold your phone vertically. Tap 'Start Capture' when ready.";
                         startCaptureButton.disabled = false;
                         startCaptureButton.textContent = 'Start Capture';
                         // Initial call to update tilt indicator based on current phone orientation
                         // We need beta here, but it's not available until the event listener is active.
                         // For now, let's just ensure the default message is shown until capture starts.
                         // The first orientation event will update it.
                    } else {
                        throw new Error("Motion and orientation access denied.");
                    }
                } else {
                     statusMessage.textContent = 'Camera permission granted. Ready to start.';
                     instructionsText.textContent = "Identify a starting feature. Hold your phone vertically. Tap 'Start Capture' when ready.";
                     startCaptureButton.disabled = false;
                     startCaptureButton.textContent = 'Start Capture';
                }
                return true;

            } catch (err) {
                console.error("Error accessing media devices or permissions:", err);
                let userMessage = `Error: ${err.message}. Please ensure camera/motion permissions are granted in your browser settings.`;
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                     userMessage = "Permission denied. Please grant camera and motion access in your browser's site settings for this page.";
                } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                     userMessage = "Camera not found. Please ensure your device has a working camera.";
                } else if (err.message.includes("motion and orientation access denied")) {
                    userMessage = "Motion and orientation access denied. Please grant permission for motion sensors.";
                }
                statusMessage.textContent = userMessage;
                instructionsText.textContent = "Please grant permissions via browser settings.";
                startCaptureButton.disabled = false;
                startCaptureButton.textContent = 'Retry Permissions';
                return false;
            }
        }

        // --- High-Resolution Capture ---
        function setupHighResCanvas() {
            if (!highResCanvas) {
                highResCanvas = document.createElement('canvas');
                highResCtx = highResCanvas.getContext('2d');
            }
            // Set canvas dimensions to match the video stream's actual dimensions
            highResCanvas.width = cameraPreview.videoWidth || HIGH_RES_WIDTH;
            highResCanvas.height = cameraPreview.videoHeight || HIGH_RES_HEIGHT;
        }

        function captureFrameAsBlob() {
            if (!highResCanvas || !highResCtx || !isCapturing) return null;

            setupHighResCanvas();

            // Draw the current video frame onto the canvas, correcting for mirroring
            highResCtx.save();
            highResCtx.scale(-1, 1); // Mirror context horizontally
            // Draw mirrored frame to the canvas at the correct position (-width, 0)
            highResCtx.drawImage(cameraPreview, -highResCanvas.width, 0, highResCanvas.width, highResCanvas.height);
            highResCtx.restore();

            return new Promise(resolve => {
                highResCanvas.toBlob(blob => {
                    resolve(blob);
                }, IMAGE_FORMAT, IMAGE_QUALITY);
            });
        }

        // --- Progress Indicator Management ---
        function updateProgressIndicator(imageBlob) {
            if (!imageBlob) return;

            const segmentIndex = capturedImages.length - 1;
            const segmentAngle = TARGET_ROTATION_DEGREES / numSegments;
            const segmentWidthRatio = segmentAngle / TARGET_ROTATION_DEGREES;

            const segmentCanvas = document.createElement('canvas');
            segmentCanvas.className = 'progress-segment';
            segmentCanvas.style.width = `${segmentWidthRatio * 100}%`;

            const segmentCtx = segmentCanvas.getContext('2d');
            const img = new Image();
            img.onload = () => {
                // Scale image to fit the segment while maintaining aspect ratio
                const segmentAspectRatio = segmentCanvas.width / segmentCanvas.height;
                const imageAspectRatio = img.width / img.height;

                let drawWidth, drawHeight, drawX, drawY;

                if (imageAspectRatio > segmentAspectRatio) { // Image is wider than segment aspect ratio
                    drawWidth = segmentCanvas.width;
                    drawHeight = segmentCanvas.width / imageAspectRatio;
                    drawX = 0;
                    drawY = (segmentCanvas.height - drawHeight) / 2; // Center vertically
                } else { // Image is taller than segment aspect ratio
                    drawHeight = segmentCanvas.height;
                    drawWidth = segmentCanvas.height * imageAspectRatio;
                    drawY = 0;
                    drawX = (segmentCanvas.width - drawWidth) / 2; // Center horizontally
                }
                segmentCtx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
            };
            img.src = URL.createObjectURL(imageBlob);

            progressRect.appendChild(segmentCanvas);

            // Update the filled width of the progress bar visually based on cumulative rotation
            const filledWidthPercentage = Math.min((currentRotation / TARGET_ROTATION_DEGREES) * 100, 100);
            progressRect.style.width = `${filledWidthPercentage}%`;
        }

        // --- Orientation Handling & Tilt Feedback ---
        function updateTiltIndicator(beta) {
            let className = '';
            let instructionText = '';
            const tiltValue = beta; // beta is pitch, 0 is horizontal, positive is up, negative is down

            // Danger states (large deviations)
            // If tilted UP significantly (beta > DANGER_THRESHOLD)
            if (tiltValue > TILT_DANGER_THRESHOLD) {
                className = 'tilt-danger';
                // Correction needed is DOWN.
                instructionText = 'Aim phone DOWN';
            }
            // If tilted DOWN significantly (beta < -DANGER_THRESHOLD)
            else if (tiltValue < -TILT_DANGER_THRESHOLD) {
                className = 'tilt-danger';
                // Correction needed is UP.
                instructionText = 'Aim phone UP';
            }
            // Warning states (moderate deviations)
            // If tilted UP moderately (beta > WARNING_THRESHOLD)
            else if (tiltValue > TILT_WARNING_THRESHOLD) {
                className = 'tilt-warning';
                // Correction needed is DOWN.
                instructionText = 'Aim phone slightly DOWN';
            }
            // If tilted DOWN moderately (beta < -WARNING_THRESHOLD)
            else if (tiltValue < -TILT_WARNING_THRESHOLD) {
                className = 'tilt-warning';
                // Correction needed is UP.
                instructionText = 'Aim phone slightly UP';
            }
            // Neutral zone
            else {
                instructionText = 'Keep phone level';
            }

            tiltIndicator.className = className; // Apply danger/warning class
            tiltIndicator.querySelector('span').textContent = instructionText;
        }

        // --- Speed Feedback ---
        function updateSpeedIndicator(speed) {
            const speedLimit = MAX_SPEED_DPS;
            const percentage = Math.min(speed / speedLimit, 1); // Cap at 100%

            speedMeter.style.width = `${percentage * 100}%`;
            speedIndicatorText.textContent = `${Math.round(speed)}°/s`;

            if (speed > speedLimit) {
                speedMeter.style.backgroundColor = '#dc3545'; // Red
            } else if (speed > speedLimit * 0.7) {
                speedMeter.style.backgroundColor = '#ffc107'; // Amber
            } else {
                speedMeter.style.backgroundColor = '#28a745'; // Green
            }
        }

        // --- Orientation Event Handler ---
        function handleOrientation(event) {
            if (!isCapturing || !event.alpha || !event.beta || !event.gamma) return;

            const alpha = event.alpha; // Rotation around Z axis (left-right turn)
            const beta = event.beta;   // Rotation around X axis (up-down tilt)
            const gamma = event.gamma; // Rotation around Y axis (left-right tilt)
            const timestamp = performance.now();

            // Initialize on first reading after capture starts
            if (initialAlpha === null) {
                initialAlpha = alpha;
                lastAlpha = alpha;
                lastTimestamp = timestamp;
                // Update tilt indicator immediately with current orientation if available
                updateTiltIndicator(beta);
                return;
            }

            // Calculate rotation delta from the *last recorded orientation*
            let deltaAlpha = alpha - lastAlpha;

            // Handle angle wrap-around (e.g., 359 -> 1 degree)
            if (deltaAlpha > 180) deltaAlpha -= 360;
            if (deltaAlpha < -180) deltaAlpha += 360;

            const deltaTime = timestamp - lastTimestamp;
            // Avoid division by zero if timestamp is the same
            const rotationSpeed = (deltaTime > 0) ? Math.abs(deltaAlpha) / (deltaTime / 1000) : 0; // Degrees per second

            // Update speed indicator
            updateSpeedIndicator(rotationSpeed);

            // Update tilt indicator
            updateTiltIndicator(beta);

            // Calculate current absolute rotation relative to the start
            let currentAbsoluteRotation = alpha - initialAlpha;
            // Normalize to 0-360 degrees range
            if (currentAbsoluteRotation > 180) currentAbsoluteRotation -= 360;
            if (currentAbsoluteRotation < -180) currentAbsoluteRotation += 360;
            currentAbsoluteRotation = (currentAbsoluteRotation + 360) % 360;

            // --- Capture Condition ---
            const segmentAngle = TARGET_ROTATION_DEGREES / numSegments;
            // Determine the angle needed to trigger the next capture, based on previous capture point
            let angleMovedSinceLastCapture = 0;
            if (lastAlpha !== null) {
                angleMovedSinceLastCapture = alpha - lastAlpha;
                if (angleMovedSinceLastCapture > 180) angleMovedSinceLastCapture -= 360;
                if (angleMovedSinceLastCapture < -180) angleMovedSinceLastCapture += 360;
                angleMovedSinceLastCapture = Math.abs(angleMovedSinceLastCapture);
            } else { // For the very first capture after the initial one
                 angleMovedSinceLastCapture = Math.abs(alpha - initialAlpha);
                 if (angleMovedSinceLastCapture > 180) angleMovedSinceLastCapture -= 360;
                 if (angleMovedSinceLastCapture < -180) angleMovedSinceLastCapture += 360;
                 angleMovedSinceLastCapture = Math.abs(angleMovedSinceLastCapture);
            }

            // Trigger capture if:
            // 1. We still need more segments (`capturedImages.length < numSegments`)
            // 2. We have rotated enough since the last capture trigger (to ensure sufficient overlap).
            // 3. The rotation speed is acceptable.
            const captureTriggerAngle = (capturedImages.length === 0) ? segmentAngle / 2 : segmentAngle; // Capture first image after half a segment's rotation from start

            if (capturedImages.length < numSegments &&
                angleMovedSinceLastCapture >= captureTriggerAngle &&
                rotationSpeed < MAX_SPEED_DPS)
            {
                captureFrameAsBlob().then(blob => {
                    if (blob) {
                        capturedImages.push(blob);
                        // Update `currentRotation` based on the absolute rotation achieved *at the time of capture*
                        currentRotation = currentAbsoluteRotation;
                        updateProgressIndicator(blob);
                        lastAlpha = alpha; // Store this alpha for next delta calculation
                        lastTimestamp = timestamp;

                        // Check for completion AFTER capturing the segment
                        if (capturedImages.length >= numSegments) {
                           // Ensure total rotation is close enough to 360 degrees
                           if (currentRotation >= TARGET_ROTATION_DEGREES - (segmentAngle / 2)) {
                              endCapture();
                           }
                        }
                    }
                });
            }
            // Update lastAlpha and lastTimestamp regardless of capture trigger for smooth tracking
            lastAlpha = alpha;
            lastTimestamp = timestamp;
        }

        // --- Capture Flow Control ---
        function startCaptureSequence() {
            if (!videoStream) {
                statusMessage.textContent = "Camera not ready. Please grant permissions.";
                return;
            }

            isCapturing = true;
            capturedImages = []; // Reset captures
            initialAlpha = null; // Reset orientation tracking
            lastAlpha = null;
            lastTimestamp = null;
            currentRotation = 0; // Reset cumulative rotation
            progressRect.style.width = '0%'; // Reset progress bar visual
            progressRect.innerHTML = ''; // Clear previous segments

            startCaptureButton.disabled = true;
            startCaptureButton.textContent = 'Capturing...';
            finalControlsDiv.style.display = 'none'; // Hide submit/retake initially
            instructionsText.textContent = "Start rotating slowly and steadily. Aim to cover 360 degrees.";
            statusMessage.textContent = ''; // Clear status

            // Prepare the high-res canvas
            setupHighResCanvas();

            // Add the first capture immediately
            captureFrameAsBlob().then(blob => {
                if (blob) {
                    capturedImages.push(blob);
                    // Set initial rotation based on first capture's orientation (relative to start)
                    // Need initialAlpha value here. If alpha reading failed, use 0.
                    currentRotation = (initialAlpha !== null ? Math.abs(lastAlpha - initialAlpha) : 0);
                    currentRotation = (currentRotation + 360) % 360; // Normalize to 0-360
                    updateProgressIndicator(blob);

                    // Now, start listening for orientation events and the animation loop
                    window.addEventListener('deviceorientation', handleOrientation, true);
                    animationFrameId = requestAnimationFrame(captureLoop);
                    statusMessage.textContent = 'Rotate now!';
                } else {
                     isCapturing = false;
                     statusMessage.textContent = "Failed to capture initial frame.";
                     startCaptureButton.disabled = false;
                     startCaptureButton.textContent = 'Start Capture';
                }
            });
        }

        function captureLoop() {
            if (!isCapturing) {
                return; // Stop the loop if capture is stopped
            }
            // The actual orientation handling and capture triggering happens in handleOrientation
            animationFrameId = requestAnimationFrame(captureLoop);
        }

        function endCapture() {
            isCapturing = false; // Stop the capture loop
            window.removeEventListener('deviceorientation', handleOrientation, true);
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            startCaptureButton.disabled = true;
            startCaptureButton.textContent = 'Capture Complete';
            finalControlsDiv.style.display = 'flex'; // Show submit/retake (flex for centering)
            instructionsText.textContent = "Capture complete! Review and submit, or retake.";
            statusMessage.textContent = 'Capture finished!';

             // Ensure the progress bar visually completes if slightly short
            const finalFilledWidth = Math.min((currentRotation / TARGET_ROTATION_DEGREES) * 100, 100);
            progressRect.style.width = `${finalFilledWidth}%`;
        }

        function submitCapture() {
            if (capturedImages.length === 0) {
                statusMessage.textContent = "No images captured yet.";
                return;
            }

            statusMessage.textContent = 'Uploading images...';
            submitCaptureButton.disabled = true;
            retakeCaptureButton.disabled = true;

            const formData = new FormData();
            capturedImages.forEach((blob, index) => {
                const filename = `capture_${String(index).padStart(3, '0')}.${IMAGE_FORMAT.split('/')[1]}`;
                formData.append('images', blob, filename);
            });

            formData.append('totalRotation', currentRotation);
            formData.append('numberOfImages', capturedImages.length);

            fetch(UPLOAD_URL, {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (response.ok) {
                    return response.json(); // Assuming server responds with JSON
                } else {
                    throw new Error(`Server responded with status ${response.status}`);
                }
            })
            .then(data => {
                console.log('Upload successful:', data);
                statusMessage.textContent = 'Upload successful!';
            })
            .catch(error => {
                console.error('Upload failed:', error);
                statusMessage.textContent = `Upload failed: ${error.message}`;
                submitCaptureButton.disabled = false; // Re-enable on failure
                retakeCaptureButton.disabled = false;
            });
        }

        function retakeCapture() {
            // Stop any ongoing capture process
            isCapturing = false;
            window.removeEventListener('deviceorientation', handleOrientation, true);
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Reset state
            capturedImages = [];
            initialAlpha = null;
            lastAlpha = null;
            lastTimestamp = null;
            currentRotation = 0;

            // Reset UI
            progressRect.innerHTML = '';
            progressRect.style.width = '0%';
            tiltIndicator.className = ''; // Reset classes
            tiltIndicator.querySelector('span').textContent = 'Keep phone level'; // Reset text
            speedMeter.style.width = '0%';
            speedIndicatorText.textContent = '0°/s';
            statusMessage.textContent = '';
            cameraPreview.style.display = 'none'; // Hide preview again
            cameraPreview.srcObject = null; // Stop the stream

            // Re-enable permission request flow
            startCaptureButton.disabled = false;
            startCaptureButton.textContent = 'Request Permissions';
            finalControlsDiv.style.display = 'none';

            // Reset instructions and status messages
            instructionsText.textContent = "Requesting camera permissions... Please grant access if prompted.";
            statusMessage.textContent = '';
            requestPermissions(); // Re-initiate permission request
        }

        // --- Initialization ---
        function init() {
            // Check for necessary APIs
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia || !window.DeviceOrientationEvent) {
                statusMessage.textContent = "This browser does not support required features (Camera API or Device Orientation).";
                instructionsText.textContent = "Please use a modern browser on a smartphone.";
                startCaptureButton.disabled = true;
                startCaptureButton.textContent = 'Unsupported';
                return;
            }

            // Add event listeners
            startCaptureButton.addEventListener('click', () => {
                // Check the button text to decide action: request permissions or start capture
                if (startCaptureButton.textContent === 'Start Capture') {
                    startCaptureSequence();
                } else {
                    // This handles the initial permission request or retrying after denial
                    requestPermissions();
                }
            });
            submitCaptureButton.addEventListener('click', submitCapture);
            retakeCaptureButton.addEventListener('click', retakeCapture);

            // Trigger initial permission request when the page loads
            requestPermissions();
        }

        // Initialize the app when the DOM is ready
        document.addEventListener('DOMContentLoaded', init);

    </script>

</body>
</html>
